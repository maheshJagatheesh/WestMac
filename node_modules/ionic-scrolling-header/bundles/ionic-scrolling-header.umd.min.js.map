{"version":3,"sources":["ng://ionic-scrolling-header/scrolling-header.directive.ts","ng://ionic-scrolling-header/scrolling-header.module.ts"],"names":["ScrollingHeaderDirective","el","renderer","zone","plt","this","showParallaxFactor","prototype","ngAfterViewInit","content","startBindings","console","error","_this","_tabs","tabbarPlacement","tabbarElement","nativeElement","contentScrollElement","getScrollElement","resize","runOutsideAngular","ionScroll","subscribe","ev","onPageScroll","event","render","ngOnDestroy","headerHeight","offsetHeight","scrollHeight","domWrite","calculateRender","Object","defineProperty","lastHeaderTop","scrollTop","target","contentHeight","clientHeight","timestamp","lastScrollTop","scrollChange","pastBottom","isStatusBarShowing","pauseForBarAnimation","hideParallaxFactor","showingHeight","setTimeout","pauseForBarDuration","log","lastTopFloored","onTranslate","setStyle","Css","transform","Directive","args","selector","ElementRef","Renderer2","NgZone","Platform","Input","ScrollingHeaderModule","NgModule","declarations","exports"],"mappings":"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","sourcesContent":["import {\r\n  Directive,\r\n  ElementRef,\r\n  Input,\r\n  Renderer2,\r\n  AfterViewInit,\r\n  OnDestroy,\r\n  NgZone\r\n} from \"@angular/core\";\r\n// Keep an eye on this. Should eventually be able to animate show/hide.\r\n// https://github.com/apache/cordova-plugin-statusbar/pull/37\r\n// import { StatusBar } from \"@ionic-native/status-bar\";\r\n\r\nimport { Platform, Content } from \"ionic-angular\";\r\n\r\n@Directive({\r\n  selector: \"[scrollingHeader]\"\r\n})\r\nexport class ScrollingHeaderDirective\r\n  implements AfterViewInit, OnDestroy {\r\n  // TODO: Consider measuring the content to see if it's worth activating.\r\n  // Or just leave it up to devs to decide which pages for which it's necessary.\r\n  // Maybe reset with exportAs - http://stackoverflow.com/a/36345948/1341838\r\n  // TODO: Handle screen resizes\r\n  private headerHeight: number;\r\n  private lastScrollTop: number = 0;\r\n  private lastHeaderTop: number = 0;\r\n\r\n  // I'm using this because I don't know when the different platforms decide\r\n  // if StatusBar.isVisible is true/false; is it immediate or after animation?\r\n  // It also prevents ongoing console warnings about Cordova.\r\n  private isStatusBarShowing: boolean = true;\r\n\r\n  private pauseForBarAnimation: boolean = false;\r\n  private pauseForBarDuration = 500;\r\n\r\n  // private savedConDim;\r\n  // render vars so we aren't scoping new ones each time\r\n  private scrollTop = 0;\r\n  private contentHeight = 0;\r\n  private scrollHeight = 0;\r\n  private scrollChange = 0;\r\n  private pastBottom: boolean;\r\n  private lastTopFloored = 0;\r\n\r\n  /**\r\n   * TODO: Some values to make a parallax effect\r\n   */\r\n\r\n  private showParallaxFactor = 0.7;\r\n  private hideParallaxFactor = this.showParallaxFactor * 0.6;\r\n\r\n  @Input(\"scrollingHeader\") content: Content;\r\n  //TODO: To cache scroll element from the content\r\n  contentScrollElement: HTMLElement;\r\n  //TODO: To cache tabbar and it's placement from the content\r\n  tabbarElement: HTMLElement;\r\n  tabbarPlacement: string;\r\n\r\n  constructor(\r\n    private el: ElementRef,\r\n    private renderer: Renderer2,\r\n    private zone: NgZone,\r\n    public plt: Platform\r\n    // private statusBar: StatusBar\r\n  ) { }\r\n  ngAfterViewInit() {\r\n    if (this.content) {\r\n      this.startBindings();\r\n      // this.startBindings_old(); \r\n    } else {\r\n      console.error(\"No content is provided for ionic scroling header!\")\r\n    }\r\n  }\r\n  startBindings() {\r\n\r\n    //init for tabs\r\n    if (this.content._tabs) {\r\n      this.tabbarPlacement = this.content._tabs[\"tabsPlacement\"];\r\n      this.tabbarElement = this.content._tabs[\"_tabbar\"].nativeElement;\r\n    }\r\n\r\n    //Cache the scroll element and tabbar inside our variables\r\n    this.contentScrollElement = this.content.getScrollElement();\r\n\r\n    // Call to init values.\r\n    this.resize();\r\n\r\n    // TODO: init the scroll view and enable scroll events\r\n\r\n    this.zone.runOutsideAngular(() => {\r\n      this.content.ionScroll.subscribe((ev) => {\r\n        this.onPageScroll(event);\r\n        this.render(ev);\r\n      });\r\n    });\r\n  }\r\n  ngOnDestroy() {\r\n  }\r\n\r\n  resize() {\r\n    // clientHeight and offsetHeight ignore bottom shadow in measurment\r\n    // but if tab is placed above , no need to consider the box shadows\r\n    if (this.tabbarPlacement == \"top\") {\r\n      this.headerHeight = this.el.nativeElement.offsetHeight;\r\n    } else {\r\n      this.headerHeight = this.el.nativeElement.scrollHeight;\r\n    }\r\n    //init content for translation\r\n    // this.renderer.setStyle(this.contentScrollElement,\"bottom\",`${-this.headerHeight}px`);\r\n  }\r\n\r\n  render(ev) {\r\n    ev.domWrite(() => {\r\n      this.calculateRender(null);\r\n    })\r\n  }\r\n\r\n  get showingHeight(): number {\r\n    return this.headerHeight - this.lastHeaderTop;\r\n  }\r\n\r\n  private onPageScroll(event) {\r\n    this.scrollTop = event.target.scrollTop;\r\n    this.contentHeight = event.target.clientHeight;\r\n    this.scrollHeight = event.target.scrollHeight;\r\n  }\r\n\r\n  calculateRender(timestamp) {\r\n    // Gotta be > 0 otherwise we aren't scrolling yet, or are rubberbanding.\r\n    // If scrollTop and lastScrollTop are the same, we've stopped scrolling\r\n    // and no need for calculations\r\n    if (this.scrollTop >= 0 && this.scrollTop !== this.lastScrollTop) {\r\n      // Obvious\r\n      this.scrollChange = this.scrollTop - this.lastScrollTop;\r\n\r\n      // Update for next loop\r\n      this.lastScrollTop = this.scrollTop;\r\n\r\n      // This is whether we are rubberbanding past the bottom\r\n      this.pastBottom = this.contentHeight + this.scrollTop > this.scrollHeight;\r\n\r\n      // GOING UP\r\n      if (this.scrollChange > 0) {\r\n        if (this.isStatusBarShowing && !this.pauseForBarAnimation) {\r\n          // StatusBar.isVisible\r\n          this.isStatusBarShowing = false;\r\n          // this.statusBar.hide();\r\n        }\r\n\r\n        // Shrink the header with the slower hideParallaxFactor\r\n        this.lastHeaderTop += this.scrollChange * this.hideParallaxFactor;\r\n\r\n        // The header only moves offscreen as far as it is tall. That leaves\r\n        // it ready to immediately scroll back when needed.\r\n        if (this.lastHeaderTop >= this.headerHeight) {\r\n          this.lastHeaderTop = this.headerHeight;\r\n        }\r\n\r\n        // GOING DOWN\r\n      } else if (this.scrollChange < 0 && !this.pastBottom) {\r\n        /**\r\n         * The combination of scrollChange < 0 && !pastBottom has to do with\r\n         * the return movement of the rubberbanding effect after you've scrolled\r\n         * all the way to the bottom (UP), and after releasing the elastic\r\n         * is bringing it back down. This allows you to reach the bottom, and\r\n         * push the header away without it sneaking back.\r\n         */\r\n\r\n        // Is 40 the right height (for iOS)? If it shows too early it looks weird.\r\n        // When animation is available, it will look better too.\r\n        if (!this.isStatusBarShowing && this.showingHeight > 40) {\r\n          // !StatusBar.isVisible\r\n          if (!this.pauseForBarAnimation) {\r\n            this.pauseForBarAnimation = true;\r\n            this.isStatusBarShowing = true;\r\n            // this.statusBar.show();\r\n\r\n            setTimeout(() => {\r\n              this.pauseForBarAnimation = false;\r\n            }, this.pauseForBarDuration);\r\n          }\r\n        }\r\n\r\n        // Reveal the header with the faster showParallaxFactor\r\n        this.lastHeaderTop += this.scrollChange * this.showParallaxFactor;\r\n        // The header can't go past (greater) zero. We should never see any\r\n        // gaps above the header, even when rubberbanding.\r\n        if (this.lastHeaderTop <= 0) {\r\n          this.lastHeaderTop = 0;\r\n        }\r\n\r\n        // console.group(`\\\\/ Going DOWN \\\\/`);\r\n        //   console.log(`scrollChange`, this.scrollChange);\r\n        //   console.log(`scrollTop`, this.scrollTop);\r\n        //   console.log(`lastTop`, this.lastHeaderTop);\r\n        // console.groupEnd();\r\n      } else {\r\n        // prevented by scrollTop !== lastScrollTop above, shouldn't happen\r\n        console.log(\"going NOWHERE\", this.scrollChange, this.scrollTop);\r\n        // cancelAnimationFrame?\r\n      }\r\n\r\n      // Use floor to prevent line flicker between ion-navbar & ion-toolbar.\r\n      // this.lastTopFloored = Math.floor(this.lastHeaderTop);\r\n      // Double tilde is a bitwize version of floor that is a touch faster:\r\n      // https://youtu.be/O39OEPC20GM?t=859\r\n      this.lastTopFloored = ~~this.lastHeaderTop;\r\n\r\n      //Translate all the elements according to the lasttopfloored\r\n      this.onTranslate(this.lastTopFloored);\r\n    } else {\r\n      // Don't do anything here since we are rubberbanding past the top.\r\n    }\r\n  }\r\n  //TODO: to make the header stable after the scroll is finished\r\n  //just to avoid the parts of the header being outside the container\r\n  //even after the scroll is finished.\r\n  // onScrollEnd() {\r\n  //   while (this.lastTopFloored > 0 && this.lastTopFloored < this.headerHeight) {\r\n  //     if (this.lastHeaderTop > this.headerHeight / 2) {\r\n  //       this.lastHeaderTop++;\r\n  //     } else {\r\n  //       this.lastHeaderTop--;\r\n  //     }\r\n  //     this.lastTopFloored = ~~(this.lastHeaderTop* this.hideParallaxFactor);\r\n  //     this.onTranslate(this.lastTopFloored);\r\n  //   }\r\n  // }\r\n\r\n  //TODO: to translate all the elements\r\n  /**\r\n   *\r\n   * @param lastTopFloored -scrolltop after applygin the parallax factor\r\n   */\r\n  onTranslate(lastTopFloored) {\r\n    this.renderer.setStyle(\r\n      this.el.nativeElement,\r\n      this.plt.Css.transform,\r\n      `translate3d(0, ${-lastTopFloored}px ,0)`\r\n    );\r\n    //TODO:to adjust our content with the header\r\n    // this.renderer.setStyle(\r\n    //   this.contentScrollElement,\r\n    //   this.plt.Css.transform,\r\n    //   `translate3d(0, ${-lastTopFloored}px ,0)`\r\n    // );\r\n    this.renderer.setStyle(\r\n      this.contentScrollElement,\r\n      \"top\",\r\n      `${-lastTopFloored}px`\r\n    );\r\n    //TODO:to adjust our tab with the header\r\n    if (this.tabbarPlacement == \"top\") {\r\n      this.renderer.setStyle(\r\n        this.tabbarElement,\r\n        this.plt.Css.transform,\r\n        `translate3d(0, ${-lastTopFloored}px ,0)`\r\n      );\r\n    }\r\n  }\r\n}\r\n","import {NgModule } from '@angular/core';\r\nimport { ScrollingHeaderDirective } from './scrolling-header.directive';\r\nexport * from \"./scrolling-header.directive\";\r\n@NgModule({\r\n  declarations: [\r\n    ScrollingHeaderDirective\r\n  ],\r\n  exports:[\r\n    ScrollingHeaderDirective\r\n  ]\r\n})\r\nexport class ScrollingHeaderModule {}\r\n"]}