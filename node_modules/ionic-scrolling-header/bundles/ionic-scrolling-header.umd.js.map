{"version":3,"file":"ionic-scrolling-header.umd.js.map","sources":["ng://ionic-scrolling-header/scrolling-header.directive.ts","ng://ionic-scrolling-header/scrolling-header.module.ts"],"sourcesContent":["import {\r\n  Directive,\r\n  ElementRef,\r\n  Input,\r\n  Renderer2,\r\n  AfterViewInit,\r\n  OnDestroy,\r\n  NgZone\r\n} from \"@angular/core\";\r\n// Keep an eye on this. Should eventually be able to animate show/hide.\r\n// https://github.com/apache/cordova-plugin-statusbar/pull/37\r\n// import { StatusBar } from \"@ionic-native/status-bar\";\r\n\r\nimport { Platform, Content } from \"ionic-angular\";\r\n\r\n@Directive({\r\n  selector: \"[scrollingHeader]\"\r\n})\r\nexport class ScrollingHeaderDirective\r\n  implements AfterViewInit, OnDestroy {\r\n  // TODO: Consider measuring the content to see if it's worth activating.\r\n  // Or just leave it up to devs to decide which pages for which it's necessary.\r\n  // Maybe reset with exportAs - http://stackoverflow.com/a/36345948/1341838\r\n  // TODO: Handle screen resizes\r\n  private headerHeight: number;\r\n  private lastScrollTop: number = 0;\r\n  private lastHeaderTop: number = 0;\r\n\r\n  // I'm using this because I don't know when the different platforms decide\r\n  // if StatusBar.isVisible is true/false; is it immediate or after animation?\r\n  // It also prevents ongoing console warnings about Cordova.\r\n  private isStatusBarShowing: boolean = true;\r\n\r\n  private pauseForBarAnimation: boolean = false;\r\n  private pauseForBarDuration = 500;\r\n\r\n  // private savedConDim;\r\n  // render vars so we aren't scoping new ones each time\r\n  private scrollTop = 0;\r\n  private contentHeight = 0;\r\n  private scrollHeight = 0;\r\n  private scrollChange = 0;\r\n  private pastBottom: boolean;\r\n  private lastTopFloored = 0;\r\n\r\n  /**\r\n   * TODO: Some values to make a parallax effect\r\n   */\r\n\r\n  private showParallaxFactor = 0.7;\r\n  private hideParallaxFactor = this.showParallaxFactor * 0.6;\r\n\r\n  @Input(\"scrollingHeader\") content: Content;\r\n  //TODO: To cache scroll element from the content\r\n  contentScrollElement: HTMLElement;\r\n  //TODO: To cache tabbar and it's placement from the content\r\n  tabbarElement: HTMLElement;\r\n  tabbarPlacement: string;\r\n\r\n  constructor(\r\n    private el: ElementRef,\r\n    private renderer: Renderer2,\r\n    private zone: NgZone,\r\n    public plt: Platform\r\n    // private statusBar: StatusBar\r\n  ) { }\r\n  ngAfterViewInit() {\r\n    if (this.content) {\r\n      this.startBindings();\r\n      // this.startBindings_old(); \r\n    } else {\r\n      console.error(\"No content is provided for ionic scroling header!\")\r\n    }\r\n  }\r\n  startBindings() {\r\n\r\n    //init for tabs\r\n    if (this.content._tabs) {\r\n      this.tabbarPlacement = this.content._tabs[\"tabsPlacement\"];\r\n      this.tabbarElement = this.content._tabs[\"_tabbar\"].nativeElement;\r\n    }\r\n\r\n    //Cache the scroll element and tabbar inside our variables\r\n    this.contentScrollElement = this.content.getScrollElement();\r\n\r\n    // Call to init values.\r\n    this.resize();\r\n\r\n    // TODO: init the scroll view and enable scroll events\r\n\r\n    this.zone.runOutsideAngular(() => {\r\n      this.content.ionScroll.subscribe((ev) => {\r\n        this.onPageScroll(event);\r\n        this.render(ev);\r\n      });\r\n    });\r\n  }\r\n  ngOnDestroy() {\r\n  }\r\n\r\n  resize() {\r\n    // clientHeight and offsetHeight ignore bottom shadow in measurment\r\n    // but if tab is placed above , no need to consider the box shadows\r\n    if (this.tabbarPlacement == \"top\") {\r\n      this.headerHeight = this.el.nativeElement.offsetHeight;\r\n    } else {\r\n      this.headerHeight = this.el.nativeElement.scrollHeight;\r\n    }\r\n    //init content for translation\r\n    // this.renderer.setStyle(this.contentScrollElement,\"bottom\",`${-this.headerHeight}px`);\r\n  }\r\n\r\n  render(ev) {\r\n    ev.domWrite(() => {\r\n      this.calculateRender(null);\r\n    })\r\n  }\r\n\r\n  get showingHeight(): number {\r\n    return this.headerHeight - this.lastHeaderTop;\r\n  }\r\n\r\n  private onPageScroll(event) {\r\n    this.scrollTop = event.target.scrollTop;\r\n    this.contentHeight = event.target.clientHeight;\r\n    this.scrollHeight = event.target.scrollHeight;\r\n  }\r\n\r\n  calculateRender(timestamp) {\r\n    // Gotta be > 0 otherwise we aren't scrolling yet, or are rubberbanding.\r\n    // If scrollTop and lastScrollTop are the same, we've stopped scrolling\r\n    // and no need for calculations\r\n    if (this.scrollTop >= 0 && this.scrollTop !== this.lastScrollTop) {\r\n      // Obvious\r\n      this.scrollChange = this.scrollTop - this.lastScrollTop;\r\n\r\n      // Update for next loop\r\n      this.lastScrollTop = this.scrollTop;\r\n\r\n      // This is whether we are rubberbanding past the bottom\r\n      this.pastBottom = this.contentHeight + this.scrollTop > this.scrollHeight;\r\n\r\n      // GOING UP\r\n      if (this.scrollChange > 0) {\r\n        if (this.isStatusBarShowing && !this.pauseForBarAnimation) {\r\n          // StatusBar.isVisible\r\n          this.isStatusBarShowing = false;\r\n          // this.statusBar.hide();\r\n        }\r\n\r\n        // Shrink the header with the slower hideParallaxFactor\r\n        this.lastHeaderTop += this.scrollChange * this.hideParallaxFactor;\r\n\r\n        // The header only moves offscreen as far as it is tall. That leaves\r\n        // it ready to immediately scroll back when needed.\r\n        if (this.lastHeaderTop >= this.headerHeight) {\r\n          this.lastHeaderTop = this.headerHeight;\r\n        }\r\n\r\n        // GOING DOWN\r\n      } else if (this.scrollChange < 0 && !this.pastBottom) {\r\n        /**\r\n         * The combination of scrollChange < 0 && !pastBottom has to do with\r\n         * the return movement of the rubberbanding effect after you've scrolled\r\n         * all the way to the bottom (UP), and after releasing the elastic\r\n         * is bringing it back down. This allows you to reach the bottom, and\r\n         * push the header away without it sneaking back.\r\n         */\r\n\r\n        // Is 40 the right height (for iOS)? If it shows too early it looks weird.\r\n        // When animation is available, it will look better too.\r\n        if (!this.isStatusBarShowing && this.showingHeight > 40) {\r\n          // !StatusBar.isVisible\r\n          if (!this.pauseForBarAnimation) {\r\n            this.pauseForBarAnimation = true;\r\n            this.isStatusBarShowing = true;\r\n            // this.statusBar.show();\r\n\r\n            setTimeout(() => {\r\n              this.pauseForBarAnimation = false;\r\n            }, this.pauseForBarDuration);\r\n          }\r\n        }\r\n\r\n        // Reveal the header with the faster showParallaxFactor\r\n        this.lastHeaderTop += this.scrollChange * this.showParallaxFactor;\r\n        // The header can't go past (greater) zero. We should never see any\r\n        // gaps above the header, even when rubberbanding.\r\n        if (this.lastHeaderTop <= 0) {\r\n          this.lastHeaderTop = 0;\r\n        }\r\n\r\n        // console.group(`\\\\/ Going DOWN \\\\/`);\r\n        //   console.log(`scrollChange`, this.scrollChange);\r\n        //   console.log(`scrollTop`, this.scrollTop);\r\n        //   console.log(`lastTop`, this.lastHeaderTop);\r\n        // console.groupEnd();\r\n      } else {\r\n        // prevented by scrollTop !== lastScrollTop above, shouldn't happen\r\n        console.log(\"going NOWHERE\", this.scrollChange, this.scrollTop);\r\n        // cancelAnimationFrame?\r\n      }\r\n\r\n      // Use floor to prevent line flicker between ion-navbar & ion-toolbar.\r\n      // this.lastTopFloored = Math.floor(this.lastHeaderTop);\r\n      // Double tilde is a bitwize version of floor that is a touch faster:\r\n      // https://youtu.be/O39OEPC20GM?t=859\r\n      this.lastTopFloored = ~~this.lastHeaderTop;\r\n\r\n      //Translate all the elements according to the lasttopfloored\r\n      this.onTranslate(this.lastTopFloored);\r\n    } else {\r\n      // Don't do anything here since we are rubberbanding past the top.\r\n    }\r\n  }\r\n  //TODO: to make the header stable after the scroll is finished\r\n  //just to avoid the parts of the header being outside the container\r\n  //even after the scroll is finished.\r\n  // onScrollEnd() {\r\n  //   while (this.lastTopFloored > 0 && this.lastTopFloored < this.headerHeight) {\r\n  //     if (this.lastHeaderTop > this.headerHeight / 2) {\r\n  //       this.lastHeaderTop++;\r\n  //     } else {\r\n  //       this.lastHeaderTop--;\r\n  //     }\r\n  //     this.lastTopFloored = ~~(this.lastHeaderTop* this.hideParallaxFactor);\r\n  //     this.onTranslate(this.lastTopFloored);\r\n  //   }\r\n  // }\r\n\r\n  //TODO: to translate all the elements\r\n  /**\r\n   *\r\n   * @param lastTopFloored -scrolltop after applygin the parallax factor\r\n   */\r\n  onTranslate(lastTopFloored) {\r\n    this.renderer.setStyle(\r\n      this.el.nativeElement,\r\n      this.plt.Css.transform,\r\n      `translate3d(0, ${-lastTopFloored}px ,0)`\r\n    );\r\n    //TODO:to adjust our content with the header\r\n    // this.renderer.setStyle(\r\n    //   this.contentScrollElement,\r\n    //   this.plt.Css.transform,\r\n    //   `translate3d(0, ${-lastTopFloored}px ,0)`\r\n    // );\r\n    this.renderer.setStyle(\r\n      this.contentScrollElement,\r\n      \"top\",\r\n      `${-lastTopFloored}px`\r\n    );\r\n    //TODO:to adjust our tab with the header\r\n    if (this.tabbarPlacement == \"top\") {\r\n      this.renderer.setStyle(\r\n        this.tabbarElement,\r\n        this.plt.Css.transform,\r\n        `translate3d(0, ${-lastTopFloored}px ,0)`\r\n      );\r\n    }\r\n  }\r\n}\r\n","import {NgModule } from '@angular/core';\r\nimport { ScrollingHeaderDirective } from './scrolling-header.directive';\r\nexport * from \"./scrolling-header.directive\";\r\n@NgModule({\r\n  declarations: [\r\n    ScrollingHeaderDirective\r\n  ],\r\n  exports:[\r\n    ScrollingHeaderDirective\r\n  ]\r\n})\r\nexport class ScrollingHeaderModule {}\r\n"],"names":["Directive","ElementRef","Renderer2","NgZone","Platform","Input","NgModule"],"mappings":"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"}
